#+SETUPFILE: "setup.org"

* TODO Namespace: thi.ng.morphogen.core

This namespace provides all core entities and operators to evolve 3d
meshes from a single seed form. The architecture is easily extensible
to support custom tree nodes & operators acting on them.

** BoxNode

The default *morphogen* tree node is represented spatially as a freeform
box with the following properties:

  : e +----+ h
  :   |\   :\
  :   |f+----+ g
  :   | |  : |
  : a +-|--+d|
  :    \|   \|
  :   b +----+ c

- 8 points
- 6 faces (quads)
- parent node
- tree depth

The quads are only an implied property and can be computed on demand
via the =faces= method of the =PNode= protocol:

*** PNode protocol

The =PNode= protocol is part of the abstraction mechanism to allow for
future extensions of *morphogen* functionality and ensures the overall
functionality is not bound to the default box-shaped entities defined
here. The protocol is purely used to define common tree operations:

#+BEGIN_SRC clojure :noweb-ref proto
  (defprotocol PNode
    (parent [_] "Returns the node's parent or `nil` if node is the root")
    (depth [_]  "Returns the node's tree depth")
    (faces [_]  "Returns a seq of the node's mesh faces (each face a vec of points)")
    (face-topology [_] "Returns number of vertices used for each face in the node"))
#+END_SRC

The =face-topology= method isn't used at current, but will be useful
in the future to restrict operator use to only compatible node types
(e.g. some operators cannot be used with triangular bases).

*** BoxNode implementation

According to the above information, the default tree node
implementation is defining nodes as =defrecord='s, with its =:points=
field being a vector of the 8 box vertices.

#+BEGIN_SRC clojure :noweb-ref node
  (defrecord BoxNode [points parent depth]
#+END_SRC

Of course, the node type must implement the =PNode= protocol in order
to participate in the tree transformation process and generate
resulting geometries. The =faces= implementation returns a vector of 6
quads arranged as shown in the diagram above.

*IMPORTANT:* The vertex ordering of each face must be counterclockwise
in order to produce outward facing face normals.

#+BEGIN_SRC clojure :noweb-ref node
    PNode
    (parent [_] parent)
    (depth [_] depth)
    (faces [{[a b c d e f g h] :points}]
      [[b c g f]  ;; front
       [a e h d]  ;; back
       [a b f e]  ;; left
       [c d h g]  ;; right
       [f g h e]  ;; top
       [a d c b]] ;; bottom
      )
    (face-topology [_] 4)
#+END_SRC

Additionally, this node type also implements the =PSubdivide= protocol
defined in the [[http://thi.ng/geom][thi.ng/geom]] library.

#+BEGIN_SRC clojure :noweb-ref node
    g/PSubdivide
    (subdivide
      [_ {:keys [cols rows slices] :or {cols 1 rows 1 slices 1}}]
      (let [ru (d/successive-nth 2 (m/norm-range cols))
	    rv (d/successive-nth 2 (m/norm-range rows))
	    rw (d/successive-nth 2 (m/norm-range slices))
	    map-p (fn [p] (->> p (unmap-uvw points) (map #(m/roundto % *eps*)) vec3))]
	(for [[w1 w2] rw, [v1 v2] rv, [u1 u2] ru]
	  (mapv map-p [[u1 v1 w1] [u1 v1 w2] [u2 v1 w2] [u2 v1 w1]
		       [u1 v2 w1] [u1 v2 w2] [u2 v2 w2] [u2 v2 w1]])))))
#+END_SRC

*** Node constructor

#+BEGIN_SRC clojure :noweb-ref node
  (defn seed
    [x]
    (let [points (cond
		  (number? x) (g/vertices (a/aabb x))
		  (sequential? x) (vec x)
		  (satisfies? g/PGraph x) (g/vertices x))]
      (BoxNode. points nil 0)))
#+END_SRC

** Operators

Node operators are responsible for transforming a tree node to
manipulate its geometry and/or produce a number of child nodes.
Through their nested application they can produce a large number of
resulting forms.

The following operators are currently implemented:

| *Operator*        | *ID*      | *Description*                                          |
|-------------------+-----------+--------------------------------------------------------|
| Subdivision       | =:sd=     | regular subdivision resulting in self-similar children |
| Inset subdivision | =:sd-ins= | subdivision through insetting along an axis            |
| Reflection        | =:refl=   | reflection of entire node on one of its sides          |

#+BEGIN_SRC clojure :noweb-ref operators
  (defmulti operator (fn [_ config] (:op config)))

  (defmethod operator nil
    [node _] nil)

#+END_SRC

*** Regular subdivision

#+BEGIN_SRC clojure :noweb-ref operators
  (defmethod operator :sd
    [node {:keys [args]}]
    (let [depth (inc (depth node))]
      (->> (g/subdivide node args)
	   (map #(BoxNode. % node depth)))))

#+END_SRC

*** Inset subdivision

The inset subdivision operator is splitting a box along a major axis
(X, Y or Z) in the following formation, resulting in five subshapes in
the specified order:

  : +---------+
  : |\   2   /|
  : | +-----+ |
  : |3|  5  |4|
  : | +-----+ |
  : |/   1   \|
  : +---------+

#+BEGIN_SRC clojure :noweb-ref operators
  (defn subdivide-inset
    [[a b c d e f g h :as points] {i :inset dir :dir}]
    (let [ii (- 1.0 i)
	  map-points (fn [base uv]
		       (mapcat
			(fn [[u v]]
			  [(unmap-uvw points (assoc (vec3) uv [u v]))
			   (unmap-uvw points (assoc base uv [u v]))])
			[[i i] [i ii] [ii ii] [ii i]]))]
      (condp = dir
	:x (let [[a1 a2 b1 b2 c1 c2 d1 d2] (map-points g/V3X :yz)]
	     [[b c d a b1 b2 a2 a1]
	      [c1 c2 d2 d1 f g h e]
	      [b c b2 b1 f g c2 c1]
	      [a1 a2 d a d1 d2 h e]
	      [b1 b2 a2 a1 c1 c2 d2 d1]])
	:y (let [[a1 a2 b1 b2 c1 c2 d1 d2] (map-points g/V3Y :xz)]
	     [[b1 b c c1 b2 f g c2]
	      [a a1 d1 d e a2 d2 h]
	      [a b b1 a1 e f b2 a2]
	      [d1 c1 c d d2 c2 g h]
	      [a1 b1 c1 d1 a2 b2 c2 d2]])
	:z (let [[a1 a2 b1 b2 c1 c2 d1 d2] (map-points g/V3Z :xy)]
	     [[a b c d a1 a2 d2 d1]
	      [b1 b2 c2 c1 e f g h]
	      [a b a2 a1 e f b2 b1]
	      [d1 d2 c d c1 c2 g h]
	      [a1 a2 d2 d1 b1 b2 c2 c1]]))))

  (defmethod operator :sd-ins
    [node {:keys [args]}]
    (let [depth (inc (depth node))]
      (->> (subdivide-inset (:points node) args)
	   (map #(BoxNode. % node depth)))))

#+END_SRC

*** Extrusion                                                           :fix:

#+BEGIN_SRC clojure :noweb-ref operators
  (defmethod operator :ext
    [{[a b c d e f g h] :points :as node} {{:keys [dir len]} :args}]
    [(BoxNode.
      (condp = dir
	:t (let [o (vec3 0 len 0)]
	     [a b c d (g/+ e o) (g/+ f o) (g/+ g o) (g/+ h o)])
	:b (let [o (vec3 0 len 0)]
	     [(g/- a o) (g/- b o) (g/- c o) (g/- d o) e f g h]))
      node (inc (depth node)))])

#+END_SRC

*** Reflection

#+BEGIN_SRC clojure :noweb-ref operators
  (defn reflect-on-plane
    [p q n]
    (g/+ q (g/reflect (g/- q p) (g/normalize n))))

  (defmethod operator :refl
    [{[a b c d e f g h] :points :as node} {{:keys [dir]} :args}]
    [node
     (BoxNode.
      (condp = dir
	:e (let [n (g/normal3* c d g)]
	     [d c (reflect-on-plane b c n) (reflect-on-plane a d n)
	      h g (reflect-on-plane f g n) (reflect-on-plane e h n)])
	:w (let [n (g/normal3* a b f)]
	     [(reflect-on-plane d a n) (reflect-on-plane c b n) b a
	      (reflect-on-plane h e n) (reflect-on-plane g f n) f e])
	:s (let [n (g/normal3* a c b)]
	     [(reflect-on-plane e a n) (reflect-on-plane f b n)
	      (reflect-on-plane g c n) (reflect-on-plane h d n)
	      a b c d])
	:n (let [n (g/normal3* e f g)]
	     [e f g h
	      (reflect-on-plane a e n) (reflect-on-plane b f n)
	      (reflect-on-plane c g n) (reflect-on-plane d h n)])
	:f (let [n (g/normal3* b c g)]
	     [b (reflect-on-plane a b n) (reflect-on-plane d c n) c
	      f (reflect-on-plane e f n) (reflect-on-plane h g n) g])
	:b (let [n (g/normal3* a e h)]
	     [(reflect-on-plane b a n) a d (reflect-on-plane c d n)
	      (reflect-on-plane f e n) e h (reflect-on-plane g h n)]))
      node (inc (depth node)))])

#+END_SRC

** Operator contructors

#+BEGIN_SRC clojure :noweb-ref op-ctors
  (defn operator-output
    [n out empty?]
    (let [default (vec (repeat n (if empty? nil {})))]
      (cond
       (map? out) (reduce-kv assoc default out)
       (sequential? out) (vec out)
       :default default)))

  (defn subdiv
    [& {:keys [cols rows slices out empty?] :or {cols 1 rows 1 slices 1}}]
    {:op :sd
     :args {:cols cols :rows rows :slices slices}
     :out (operator-output (* cols rows slices) out empty?)})

  (defn subdiv-inset
    [& {:keys [dir inset out empty?] :or {dir :y inset 0.25}}]
    {:op :sd-ins
     :args {:dir dir :inset inset}
     :out (operator-output 5 out empty?)})

  (defn reflect
    [& {:keys [dir out empty?] :or {dir :n}}]
    {:op :refl
     :args {:dir dir}
     :out (operator-output 2 out empty?)})
#+END_SRC

** Tree walking & node processing

#+BEGIN_SRC clojure :noweb-ref tree-walk
  (defn walk
    ([seed tree max-depth] (walk seed tree [] max-depth))
    ([node tree acc max-depth]
       ;;(prn :d (depth node) (:points node) tree)
       (if (< (depth node) max-depth)
	 (let [children (operator node tree)]
	   (if children
	     (->> children
		  (interleave (:out tree))
		  (partition 2)
		  (reduce
		   (fn [acc [ctree c]]
		     ;;(prn :c (:points c) :ctree ctree)
		     (if ctree
		       (walk c ctree acc max-depth)
		       acc))
		   acc))
	     (conj acc (gm/into-mesh (faces node)))))
	 (conj acc (gm/into-mesh (faces node))))))
#+END_SRC

** Helper functions

#+BEGIN_SRC clojure :noweb-ref helpers
  (defn unmap-uvw
    [[a b c d e f g h] [u v w]]
    (g/mix
     (g/mix a d e h u v)
     (g/mix b c f g u v) w))
#+END_SRC

** Mesh functions

#+BEGIN_SRC clojure :noweb-ref meshing
  (defn sphere-seg
    [n h inset wall]
    (let [theta (/ m/PI n)
	  off (vec3 0 0 h)
	  poly (g/rotate (g/as-polygon (c/circle) n) (- (- m/HALF_PI) theta))
	  [b c] (map vec3 (g/vertices poly))
	  [a d] (map vec3 (g/vertices (p/inset-polygon poly (- wall))))
	  [f g] (map #(g/+ off %) (g/vertices (p/inset-polygon poly (- inset))))
	  [e h] (map #(g/+ off %) (g/vertices (p/inset-polygon poly (- (- inset) wall))))]
      [b f g c a e h d]))

  (defn csg-union-mesh
    [meshes]
    (->> meshes
	 (map csg/mesh->csg)
	 (reduce csg/union)
	 (csg/csg->mesh)))

  (defn union-mesh
    [meshes]
    (reduce g/into-mesh meshes))

  (defn save-mesh
    ([seed tree] (save-mesh seed tree "p.ply" 1e6))
    ([seed tree path] (save-mesh seed tree path 1e6))
    ([seed tree path max-depth]
       (with-open [o (io/output-stream path)]
	 (->> (walk seed tree max-depth)
	      (union-mesh)
	      (mio/write-ply o)))))

#+END_SRC

** Complete namespace

#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/morphogen/core.cljx :noweb yes :mkdirp yes :padline no
  (ns thi.ng.morphogen.core
    (:require
     [thi.ng.geom.core :as g :refer [vec3]]
     [thi.ng.geom.circle :as c]
     ;;[thi.ng.geom.rect :as r]
     [thi.ng.geom.polygon :as p]
     [thi.ng.geom.aabb :as a]
     ;;[thi.ng.geom.quad :as q]
     [thi.ng.geom.gmesh :as gm]
     [thi.ng.geom.csg :as csg]
     [thi.ng.geom.meshio :as mio]
     [thi.ng.common.data.core :as d]
     [thi.ng.common.math.core :as m :refer [*eps*]]
     [clojure.java.io :as io]
     [clojure.pprint :refer [pprint]]))

  (declare operator)

  <<helpers>>

  <<proto>>

  <<node>>

  <<operators>>

  <<op-ctors>>

  <<tree-walk>>

  <<meshing>>
#+END_SRC

* TODOs

- add octree mesh for snapping verts
