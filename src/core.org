#+SETUPFILE: "setup.org"

* Namespace: thi.ng.morphogen.core

This namespace provides all core entities and operators to evolve 3d
meshes from a single seed form as described superficially in
[[file:index.org][index.org]]. The architecture defined here is easily extensible to
support custom tree nodes & operators acting on them.

In order to apply nested transformation to a given seed form, we need
to define a tree structure. For our approach we will actually use two
of them: one to define the nesting of operators and another one to
define temporary tree nodes representing the actual transformed
geometries. The latter is merely an internal implementation detail and
users of the library will only have to mainly deal with the operator
tree. On the other hand, this dichotomy allows users to easily add
their own operators & geometry node types and mix them with the
defaults provided here.

** Geometry nodes

*** BoxNode

The default *morphogen* tree node is represented spatially as a freeform
box with the following properties:

  : e +----+ h
  :   |\   :\
  :   |f+----+ g
  :   | |  : |
  : a +-|--+d|
  :    \|   \|
  :   b +----+ c

- 8 points
- 6 faces (quads)
- parent node
- tree depth

The quads are only an implied property and can be computed on demand
via the =faces= method of the =PNode= protocol:

**** PNode protocol

The =PNode= protocol is part of the abstraction mechanism to allow for
future extensions of *morphogen* functionality and ensures the overall
functionality is not bound to the default box-shaped entities defined
here. The protocol is purely used to define basic operations for
navigating the tree (e.g. some operators might want access to parent
nodes in order to achieve contraints etc.) and to extract facets for
final mesh assembly:

#+BEGIN_SRC clojure :noweb-ref proto
  (defprotocol PNode
    (parent [_] "Returns the node's parent or `nil` if node is the root")
    (depth [_]  "Returns the node's tree depth")
    (faces [_]  "Returns a seq of the node's mesh faces (each face a vec of points)")
    (face-topology [_] "Returns number of vertices used for each face in the node"))
#+END_SRC

The =face-topology= method isn't used at current, but will be useful
in the future to restrict operator use to only compatible node types
(e.g. some operators cannot be used with triangular bases).

**** BoxNode implementation

According to the above information, the default tree node
implementation is defining nodes as =defrecord='s, with its =:points=
field being a vector of the 8 box vertices (in this order: a, b, c .. h).

#+BEGIN_SRC clojure :noweb-ref node
  (defrecord BoxNode [points parent depth]
#+END_SRC

Of course, the node type must implement the =PNode= protocol in order
to participate in the tree transformation process and generate
resulting geometries. The =faces= implementation returns a vector of 6
quads arranged as shown in the diagram above.

*IMPORTANT:* The vertex ordering of each face must be counterclockwise
in order to produce outward facing face normals.

#+BEGIN_SRC clojure :noweb-ref node
    PNode
    (parent [_] parent)
    (depth [_] depth)
    (faces [{[a b c d e f g h] :points}]
      [[b c g f]  ;; front
       [a e h d]  ;; back
       [a b f e]  ;; left
       [c d h g]  ;; right
       [f g h e]  ;; top
       [a d c b]] ;; bottom
      )
    (face-topology [_] 4)
#+END_SRC

Additionally, this node type also implements the =PSubdivide= protocol
defined in the [[http://thi.ng/geom][thi.ng/geom]] library.

#+BEGIN_SRC clojure :noweb-ref node
    g/PSubdivide
    (subdivide
      [_ {:keys [cols rows slices] :or {cols 1 rows 1 slices 1}}]
      (let [ru (d/successive-nth 2 (m/norm-range cols))
	    rv (d/successive-nth 2 (m/norm-range rows))
	    rw (d/successive-nth 2 (m/norm-range slices))
	    map-p (fn [p] (->> p (unmap-uvw points) (map #(m/roundto % *eps*)) vec3))]
	(for [[w1 w2] rw, [v1 v2] rv, [u1 u2] ru]
	  (mapv map-p [[u1 v1 w1] [u1 v1 w2] [u2 v1 w2] [u2 v1 w1]
		       [u1 v2 w1] [u1 v2 w2] [u2 v2 w2] [u2 v2 w1]])))))
#+END_SRC

**** Node constructor

Since the seed form needs to be a valid =BoxNode= instance (or at
least implement the =PNode= protocol) in order to be transformed, the
following constructor function can create a =BoxNode= in different
ways:

#+BEGIN_SRC clojure :noweb-ref node
  (defn seed
    [x]
    (let [points (cond
                  (number? x) (g/vertices (a/aabb x))
                  (sequential? x) (vec x)
                  (satisfies? g/PGraph x) (g/vertices x))]
      (BoxNode. points nil 0)))
#+END_SRC

** Operators

Node operators are responsible for transforming a geometry node to
manipulate its points and/or produce a number of child nodes. Through
their nested application they can produce a large number of resulting
forms. The operators defined here are only applicable to the =BoxNode=
type, but as we will see they're technically trivial and can be used
as guidance to provide similar operators for custom nodes.

The following operators are currently implemented:

| *Operator*        | *ID*          | *Description*                                                              |
|-------------------+---------------+----------------------------------------------------------------------------|
| Subdivision       | =:sd=         | Regular subdivision resulting in self-similar children                     |
| Inset subdivision | =:sd-inset=   | Subdivision through insetting along an axis                                |
| Reflection        | =:reflect=    | Reflection of entire node on one of its sides                              |
| Extrusion         | =:extrude=    | Extrusion of the node along the normal of one of its sides                 |
| Scale edge(s)     | =:scale-edge= | Scale an edge and set its symmetric opposite (in X, Y or Z) to same length |

The *ID* column states the IDs used to match operators to their
implementation using the =operator= multimethod, described below.

*** Operator node structure & evaluation

Unlike the route taken for geometry nodes (using protcols &
defrecords), operator nodes (the entire tree, really) are simple
Clojure maps with this basic structure:

#+BEGIN_SRC clojure
  {:op :operator-id            ;; multimethod operator id
   :args {:foo 23 :bar 42 ...} ;; map of arbitrary transformation arguments
   :out [{:op ...} nil {} ...] ;; vector of nested child operators
  }
#+END_SRC

The =:out= vector deserves some more attention and discussion how
tree evaluation work in our case: At the first iteration the root node
operator is applied to the given seed form. Different operators
(and their given arguments) will produce different numbers
of geometry child nodes. For example, whereas the [[Reflection]] operator
will always return two nodes (the original and reflected version), the
[[Regular subdivision]] operator can produce any number of children. Based
on that, the =:out= vector of an operator node should have the same
number of elements as is produced by the operator. The next stage of
tree evaluation is then matching operator elements from the =:out=
vector to child nodes produced by the operator and is descending
further into the tree.

**** Branch termination & leaf nodes

An interesting aspect of this approach is that we can terminate
branches by explicitly setting elements of this =:out= vector to
=nil=. If that is the case, no further descent is possible and no mesh
will be collected from the related geometry node. Therefore, this
mechanism can be used to create holes/concavities in the resulting
mesh structure. Alternatively, we use an empty map ={}= (without any
=:op= key) to specify a leaf node of the tree. *Final mesh information
is collected /only/ from leaf nodes.* Another example illustrates this
better:

#+BEGIN_SRC clojure
  {:op :sd
   :args {:cols 3}
   :out [{} nil {}]}
#+END_SRC

***** TODO insert image

This operator node defines a 3x1 subdivision of the node's box into 3
columns along its A->D edge (see point layout above) and is therefore
resulting in 3 child nodes. However, the middle element of the =:out=
vector is =nil= and is therefore removing the 2nd column entirely. The
other two elements in =:out= are marked as leaf nodes and therefore
will result in a mesh of two isolated columns. In contrast, the
following example uses the same initial setup, but subdivides the 1st
child node further:

#+BEGIN_SRC clojure
  {:op :sd
   :args {:cols 3}                ;; split root in 3 cols
   :out [{:op :sd
          :args {:cols 2 :rows 2} ;; split 1st child into 2x2
          :out [nil nil nil {}]}  ;; only keep top-right child
         nil                      ;; ignore 2nd child of root
         {}]}                     ;; mark last child as leaf (no-op)
#+END_SRC

***** TODO insert image

*** Operator multimethod

As stated previously, the operators are implemented as Clojure
multimethod in order to allow for easy addition of custom operators
without requiring any other changes. The multimethod is using both the
geometry node type and operator ID to dispatch to the actual
implementations:

#+BEGIN_SRC clojure :noweb-ref operators
  (defmulti operator
    (fn [g-node {:keys [op]}]
     (if op [(type g-node) op])))

  ;; leaf node operator (no-op)
  (defmethod operator nil [_ _] nil)

#+END_SRC

*** Regular subdivision

| *Argument* | *Value description*             | *Default* |
|------------+---------------------------------+-----------|
| =:cols=    | number of splits along AD edge  | 1         |
|------------+---------------------------------+-----------|
| =:rows=    | number of splits along AE edge  | 1         |
|------------+---------------------------------+-----------|
| =:slices=  | number of splits along AB edges | 1         |

#+BEGIN_SRC clojure :noweb-ref operators
  (defmethod operator [BoxNode :sd]
    [node {:keys [args]}]
    (let [depth (inc (depth node))]
      (->> (g/subdivide node args)
	   (map #(BoxNode. % node depth)))))

#+END_SRC

*** Inset subdivision

The inset subdivision operator is splitting a node along one of its
local major axes (X, Y or Z) in the following formation, resulting in
five child nodes in the specified order:

  : +---------+
  : |\   2   /|
  : | +-----+ |
  : |3|  5  |4|
  : | +-----+ |
  : |/   1   \|
  : +---------+

| *Argument* | *Value description*                                                      | *Default* |
|------------+--------------------------------------------------------------------------+-----------|
| =:dir=     | =:x= split from right side (as viewed so that face =[c d h g]= is front) | :y        |
|            | =:y= from top (as viewed so that face =[e f g h]= is front)              |           |
|            | =:z= from front (as viewed so that face =[b c g f]= is front)            |           |
|------------+--------------------------------------------------------------------------+-----------|
| =:inset=   | percentage to inset corner points (0.0 ... < 0.5)                        | 0.25      |

#+BEGIN_SRC clojure :noweb-ref operators
  (defn subdivide-inset
    [[a b c d e f g h :as points]
     {i :inset dir :dir :or {i 0.1 dir :y}}]
    (let [ii (- 1.0 i)
          map-points (fn [base uv]
                       (mapcat
                        (fn [[u v]]
                          [(unmap-uvw points (assoc (vec3) uv [u v]))
                           (unmap-uvw points (assoc base uv [u v]))])
                        [[i i] [i ii] [ii ii] [ii i]]))]
      (condp = dir
        :x (let [[a1 a2 b1 b2 c1 c2 d1 d2] (map-points g/V3X :yz)]
             [[b c d a b1 b2 a2 a1]
              [c1 c2 d2 d1 f g h e]
              [b c b2 b1 f g c2 c1]
              [a1 a2 d a d1 d2 h e]
              [b1 b2 a2 a1 c1 c2 d2 d1]])
        :y (let [[a1 a2 b1 b2 c1 c2 d1 d2] (map-points g/V3Y :xz)]
             [[b1 b c c1 b2 f g c2]
              [a a1 d1 d e a2 d2 h]
              [a b b1 a1 e f b2 a2]
              [d1 c1 c d d2 c2 g h]
              [a1 b1 c1 d1 a2 b2 c2 d2]])
        :z (let [[a1 a2 b1 b2 c1 c2 d1 d2] (map-points g/V3Z :xy)]
             [[a b c d a1 a2 d2 d1]
              [b1 b2 c2 c1 e f g h]
              [a b a2 a1 e f b2 b1]
              [d1 d2 c d c1 c2 g h]
              [a1 a2 d2 d1 b1 b2 c2 c1]]))))
  
  (defmethod operator [BoxNode :sd-inset]
    [node {:keys [args]}]
    (let [depth (inc (depth node))]
      (->> (subdivide-inset (:points node) args)
           (map #(BoxNode. % node depth)))))
  
#+END_SRC

*** Extrusion

| *Argument* | *Value description*                   | *Default* |
|------------+---------------------------------------+-----------|
| =:dir=     | =:e= reflect on right plane [c d h g] | :n        |
|            | =:w= left plane [a b f e]             |           |
|            | =:n= top plane [e f g h]              |           |
|            | =:s= bottom plane [a b c d]           |           |
|            | =:f= front plane [b c g f]            |           |
|            | =:b= back plane [a d h e]             |           |
|------------+---------------------------------------+-----------|
| =:len=     | Extrusion length                      | 1.0       |

#+BEGIN_SRC clojure :noweb-ref operators
  (defmethod operator [BoxNode :extrude]
    [{[a b c d e f g h] :points :as node}
     {{:keys [dir len] :or {dir :n len 1.0}} :args}]
    [(BoxNode.
      (condp = dir
        :e (let [o (g/* (g/normal3* c d h) len)]
             [a b (g/+ c o) (g/+ d o) e f (g/+ g o) (g/+ h o)])
        :w (let [o (g/* (g/normal3* a b f) len)]
             [(g/+ a o) (g/+ b o) c d (g/+ e o) (g/+ f o) g h])
        :n (let [o (g/* (g/normal3* e f g) len)]
             [a b c d (g/+ e o) (g/+ f o) (g/+ g o) (g/+ h o)])
        :s (let [o (g/* (g/normal3* a d c) len)]
             [(g/- a o) (g/- b o) (g/- c o) (g/- d o) e f g h])
        :f (let [o (g/* (g/normal3* b c g) len)]
             [a (g/+ b o) (g/+ c o) d e (g/+ f o) (g/+ g o) h])
        :b (let [o (g/* (g/normal3* c d e) len)]
             [(g/+ a o) b c (g/+ d o) (g/+ e o) f g (g/+ h o)]))
      node (inc (depth node)))])
  
#+END_SRC

*** Reflection

The reflection operator simply mirrors a given node on one of its
sides and returns the original node and the mirrored version.

| *Argument* | *Value description*                   | *Default* |
|------------+---------------------------------------+-----------|
| =:dir=     | =:e= reflect on right plane [c d h g] | :n        |
|            | =:w= left plane [a b f e]             |           |
|            | =:n= top plane [e f g h]              |           |
|            | =:s= bottom plane [a b c d]           |           |
|            | =:f= front plane [b c g f]            |           |
|            | =:b= back plane [a d h e]             |           |

#+BEGIN_SRC clojure :noweb-ref operators
  (defn reflect-on-plane
    [p q n]
    (g/+ q (g/reflect (g/- q p) (g/normalize n))))
  
  (defmethod operator [BoxNode :reflect]
    [{[a b c d e f g h] :points :as node}
     {{:keys [dir] :or {dir :n}} :args}]
    [node
     (BoxNode.
      (condp = dir
        :e (let [n (g/normal3* c d g)]
             [d c (reflect-on-plane b c n) (reflect-on-plane a d n)
              h g (reflect-on-plane f g n) (reflect-on-plane e h n)])
        :w (let [n (g/normal3* a b f)]
             [(reflect-on-plane d a n) (reflect-on-plane c b n) b a
              (reflect-on-plane h e n) (reflect-on-plane g f n) f e])
        :s (let [n (g/normal3* a c b)]
             [(reflect-on-plane e a n) (reflect-on-plane f b n)
              (reflect-on-plane g c n) (reflect-on-plane h d n)
              a b c d])
        :n (let [n (g/normal3* e f g)]
             [e f g h
              (reflect-on-plane a e n) (reflect-on-plane b f n)
              (reflect-on-plane c g n) (reflect-on-plane d h n)])
        :f (let [n (g/normal3* b c g)]
             [b (reflect-on-plane a b n) (reflect-on-plane d c n) c
              f (reflect-on-plane e f n) (reflect-on-plane h g n) g])
        :b (let [n (g/normal3* a e h)]
             [(reflect-on-plane b a n) a d (reflect-on-plane c d n)
              (reflect-on-plane f e n) e h (reflect-on-plane g h n)]))
      node (inc (depth node)))])
  
#+END_SRC

*** Scale edge

| *Argument* | *Value description*                                      | *Default*   |
|------------+----------------------------------------------------------+-------------|
| =:edge=    | =:ab=, =:bc=, =:cd=, =:ad= (bottom face edges)           | =nil=       |
|            | =:ef=, =:fg=, =:gh=, =:eh= (top face edges)              | (mandatory) |
|            | =:ae=, =:bf=, =:cg=, =:dh= (sides)                       |             |
|------------+----------------------------------------------------------+-------------|
| =:sym=     | =:x= also scale edge on opposite side (along =:ad= edge) | =nil=       |
|            | =:y= (along =:ae= edge)                                  | (mandatory) |
|            | =:z= (along =:ab= edge)                                  |             |
|------------+----------------------------------------------------------+-------------|
| =:scale=   | scale factor                                             | 0.5         |

#+BEGIN_SRC clojure :noweb-ref operators
  (defmethod operator [BoxNode :scale-edge]
    [{[a b c d e f g h] :points :as node}
     {{:keys [edge sym scale] :or {scale 0.5}} :args}]
    (let [s (* scale 0.5)
          scale-if (fn [sid p q s]
                     (if (= sid sym)
                       [(g/mix p q s) (g/mix q p s)] [p q]))
          scale (fn [p q s1 i j s2 k l]
                  (let [p' (g/mix p q s), q' (g/mix q p s)
                        dpq (g/dist p' q')
                        [i j] (scale-if s1 i j (/ dpq (g/dist i j) 2))
                        [k l] (scale-if s2 k l (/ dpq (g/dist k l) 2))]
                    [p' q' i j k l]))]
      [(BoxNode.
        (condp = edge
          ;; bottom
          :ab (let [[a b c d e f] (scale a b :x c d :y e f)]
                [a b c d e f g h])
          :bc (let [[b c a d f g] (scale b c :z a d :y f g)]
                [a b c d e f g h])
          :cd (let [[c d a b g h] (scale c d :x a b :y g h)]
                [a b c d e f g h])
          :ad (let [[a d b c e h] (scale a d :z b c :y e h)]
                [a b c d e f g h])
          ;; top
          :ef (let [[e f g h a b] (scale e f :x g h :y a b)]
                [a b c d e f g h])
          :fg (let [[f g e h b c] (scale f g :z e h :y b c)]
                [a b c d e f g h])
          :gh (let [[g h e f c d] (scale g h :x e f :y c d)]
                [a b c d e f g h])
          :eh (let [[e h f g a d] (scale e h :z f g :y a d)]
                [a b c d e f g h])
          ;; left
          :ae (let [[a e d h b f] (scale a e :x d h :z b f)]
                [a b c d e f g h])
          :bf (let [[b f ] (scale b f :x c g :z a b)]
                [a b c d e f g h])
          ;; right
          :cg (let [[c g b f d h] (scale c g :x b f :z d h)]
                [a b c d e f g h])
          :dh (let [[d h a e c g] (scale d h :x a e :z c g)]
                [a b c d e f g h]))
        node (inc (depth node)))]))
#+END_SRC
** Operator constructors

#+BEGIN_SRC clojure :noweb-ref op-ctors
  (defn operator-output
    [n out empty?]
    (let [default (vec (repeat n (if empty? nil {})))]
      (cond
       (map? out) (reduce-kv assoc default out)
       (sequential? out) (vec out)
       :default default)))
  
  (defn subdiv
    [& {:keys [cols rows slices out empty?] :or {cols 1 rows 1 slices 1}}]
    {:op :sd
     :args {:cols cols :rows rows :slices slices}
     :out (operator-output (* cols rows slices) out empty?)})
  
  (defn subdiv-inset
    [& {:keys [dir inset out empty?] :or {dir :y inset 0.25}}]
    {:op :sd-inset
     :args {:dir dir :inset inset}
     :out (operator-output 5 out empty?)})
  
  (defn reflect
    [& {:keys [dir out empty?] :or {dir :n}}]
    {:op :reflect
     :args {:dir dir}
     :out (operator-output 2 out empty?)})
  
  (defn extrude
    [& {:keys [dir len out empty?] :or {dir :n len 1.0}}]
    {:op :extrude
     :args {:dir dir :len len}
     :out (operator-output 1 out empty?)})
  
  (defn scale-edge
    [edge sym & {:keys [scale out] :or {scale 0.5}}]
    {:op :scale-edge
     :args {:edge edge :sym sym :scale scale}
     :out (operator-output 1 out false)})
#+END_SRC

** Tree walking & node processing

The following little function is truly at the heart of this library
and is responsible for walking the operator tree, applying all
transformations and collecting mesh geometries from any leaf nodes.

In order to help with debugging complex trees, but also to allow for
only partial descents into the tree, a maximum tree depth can be
specified to stop further descending and consider nodes at this depth
as leaves. This way it's also easy to create an animation of the tree
transformation.

*** TODO switch to using trampoline to avoid blowing stack for deep trees

#+BEGIN_SRC clojure :noweb-ref tree-walk
  (defn walk
    ([seed tree] (walk seed tree [] 1e6))
    ([seed tree max-depth] (walk seed tree max-depth []))
    ([node tree max-depth acc]
       ;;(prn :d (depth node) (:points node) tree)
       (if (< (depth node) max-depth)
         (let [children (operator node tree)]
           (if children
             (->> children
                  (interleave (:out tree))
                  (partition 2)
                  (reduce
                   (fn [acc [ctree c]]
                     ;;(prn :c (:points c) :ctree ctree)
                     (if ctree
                       (walk c ctree max-depth acc)
                       acc))
                   acc))
             (conj acc (gm/into-mesh (faces node)))))
         (conj acc (gm/into-mesh (faces node))))))
#+END_SRC

** Helper functions

#+BEGIN_SRC clojure :noweb-ref helpers
  (defn unmap-uvw
    "Takes a seq of 8 points defining a box and vector of normalized
    u,v,w coordinates. Applies trilinear interpolation to compute point
    within the box:
    u is coord along AD/BC edge, v along AE/BF, w along AB/DC."
    [[a b c d e f g h] [u v w]]
    (g/mix (g/mix a d e h u v) (g/mix b c f g u v) w))
  
  (defn child-path
    "Takes a seq of child indices and constructs a lookup path/vector
    for them by interleaving `:out` in the seq:
        (child-path [1 0 2]) => [:out 1 :out 0 :out 2]"
    [path] (vec (interleave (repeat :out) path)))
  
  (defn apply-recursively
    "Recursively injects tree into itself `n` times, starting at given
    child path. At each subsequent level, the original tree given is
    injected at index `id` of the `:out` child node vector. The initial
    path is simply a seq of indices and will be translated into an
    actual path using the `child-path` fn."
    [tree n path id]
    (loop [t' tree, path (child-path path), n (dec n)]
      (if (pos? n)
        (recur (assoc-in t' path tree) (into path [:out id]) (dec n))
        t')))
#+END_SRC

** Mesh functions

#+BEGIN_SRC clojure :noweb-ref meshing
  (defn circle-lattice-seg
    [n h wall]
    (let [theta (/ m/PI n)
          off (vec3 0 0 h)
          poly (g/rotate (g/as-polygon (c/circle) n) (- (- m/HALF_PI) theta))
          [b c] (map vec3 (g/vertices poly))
          [a d] (map vec3 (g/vertices (p/inset-polygon poly (- wall))))
          [f g] (map #(g/+ off %) [b c])
          [e h] (map #(g/+ off %) [a d])]
      [b f g c a e h d]))
  
  (defn sphere-lattice-seg
    [n h inset wall]
    (let [theta (/ m/PI n)
          off (vec3 0 0 h)
          poly (g/rotate (g/as-polygon (c/circle) n) (- (- m/HALF_PI) theta))
          [b c] (map vec3 (g/vertices poly))
          [a d] (map vec3 (g/vertices (p/inset-polygon poly (- wall))))
          [f g] (map #(g/+ off %) (g/vertices (p/inset-polygon poly (- inset))))
          [e h] (map #(g/+ off %) (g/vertices (p/inset-polygon poly (- (- inset) wall))))]
      [b f g c a e h d]))
  
  (defn csg-union-mesh
    [meshes]
    (->> meshes
         (map csg/mesh->csg)
         (reduce csg/union)
         (csg/csg->mesh)))
  
  (defn union-mesh
    [meshes]
    (reduce g/into-mesh meshes))
  
  (defn save-mesh
    ([seed tree] (save-mesh seed tree "p.ply" 1e6))
    ([seed tree path] (save-mesh seed tree path 1e6))
    ([seed tree path max-depth]
       (with-open [o (io/output-stream path)]
         (->> (walk seed tree max-depth)
              (union-mesh)
              (mio/write-ply o)))))
  
#+END_SRC

** Complete namespace

With all elements in place now, we only need to bundle them all up
into a proper Clojure namespace...

#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/morphogen/core.cljx :noweb yes :mkdirp yes :padline no
  (ns thi.ng.morphogen.core
    (:require
     [thi.ng.geom.core :as g :refer [vec3]]
     [thi.ng.geom.circle :as c]
     [thi.ng.geom.polygon :as p]
     [thi.ng.geom.aabb :as a]
     [thi.ng.geom.gmesh :as gm]
     [thi.ng.geom.csg :as csg]
     [thi.ng.geom.meshio :as mio]
     [thi.ng.common.data.core :as d]
     [thi.ng.common.math.core :as m :refer [*eps*]]
     [clojure.java.io :as io]
     [clojure.pprint :refer [pprint]]))

  (declare operator)

  <<helpers>>

  <<proto>>

  <<node>>

  <<operators>>

  <<op-ctors>>

  <<tree-walk>>

  <<meshing>>
#+END_SRC

* TODOs

- add octree mesh for snapping verts
- scale-edge op should produce planar results (or add as new op)
- add desc for side IDs (east/west ...)

