#+SETUPFILE: "setup.org"

* Examples & test trees

All examples defined below will be tangled into the =/babel/examples/=
subfolder of this project and can be directly loaded into a running
REPL, e.g. via =(load-file "examples/ex03.clj")=.

Each example generates a 3D model in Stanford PLY format, which is
saved in this file [[../babel/p.ply]] and can then be imported into other
3d applications. If you need a simple mesh viewer, we recommend
[[http://meshlab.sf.net][Meshlab]].

** Template for namespace setup
#+BEGIN_SRC clojure :noweb-ref require-mg
  (:require
   [thi.ng.morphogen.core :as mg]
   [thi.ng.geom.core :as g :refer [vec3]]
   [thi.ng.geom.aabb :as a])
  (:import
   [thi.ng.morphogen.core BoxNode])
#+END_SRC

** Extruded aluminium style module

[[../assets/img/morphogen-ex01.jpg]]

#+BEGIN_SRC clojure :tangle ../babel/examples/ex01.clj :noweb yes :mkdirp yes :padline no
  (ns ex01
    <<require-mg>>)
  
  (def tree
    (let [branch (fn [[dir lpos]]
                   (mg/subdiv-inset
                    :dir :y :inset 0.05
                    :out {lpos (mg/subdiv dir 3 :out {1 nil}) 4 nil}))
          module (mg/subdiv-inset
                  :dir :y :inset 0.4
                  :out (mapv branch [[:cols 0] [:cols 1] [:slices 2] [:slices 3]]))]
      (mg/subdiv
       :rows 3
       :out [module
             (mg/subdiv
              :rows 3 :out {1 (mg/subdiv :cols 3 :out [nil {} nil])})
             module])))
  
  (mg/save-mesh (mg/seed (a/aabb 1 0.5 1)) tree)
#+END_SRC

** Stripy module (heatsink?)

[[../assets/img/morphogen-ex02.jpg]]

#+BEGIN_SRC clojure :tangle ../babel/examples/ex02.clj :noweb yes :mkdirp yes :padline no
  (ns ex02
    <<require-mg>>)
  
  (defn make-stripes
    ([n] (make-stripes even? n))
    ([pred n]
       (mg/subdiv :cols n :out (mapv #(if (pred %) {}) (range n)))))
  
  (defn stripes*
    [pred n]
    (loop [acc (make-stripes pred n) i (if (= pred even?) 1 0)]
      (if (< i n)
        (recur
         (assoc-in
          acc [:out i]
          (mg/subdiv
           :rows 3 :slices 3 :out {4 {}} :empty? true))
         (+ i 2))
        acc)))
  
  (def tree
    (let [se (stripes* even? 9)
          so (mg/subdiv :rows 2 :out [(stripes* odd? 9)])]
      (mg/subdiv :cols 3 :slices 3 :out [se so se se nil se se so se])))
  
  (mg/save-mesh (mg/seed (a/aabb 1 0.2 1)) tree)
#+END_SRC

** Hexagon hemisphere

[[../assets/img/morphogen-ex03.jpg]]

The following short code is all what's needed to generate the mesh
shown in the image above: A sphere segment (generated with
=sphere-seg=) is used as seed shape to create a number of hexagons,
which due to the side angles of the seed shape automatically arrange
themselves in a spherical constellation. The entire structure is only
using the =reflection= operator. Since the operator tree is context
free & distinct from any actual geometry node hierarchy, we can encode
various repetitive sub-transformations using simple functions.

#+BEGIN_SRC clojure :tangle ../babel/examples/ex03.clj :noweb yes :mkdirp yes :padline no
  (ns ex03
    <<require-mg>>)
  
  (defn apply-recursively
    "Recursively injects tree into itself n times. At each level, the
    original tree given is injected at index `id` of the `:out` child
    node vector."
    [tree n id]
    (loop [t' tree, path [:out id], n (dec n)]
      (if (pos? n)
        (recur (assoc-in t' path tree) (into path [:out id]) (dec n))
        t')))
  
  (def child-path #(interleave (repeat :out) %))
  
  (def t
    "Hexagon arrangement as sequence of nested reflections."
    (let [ring (apply-recursively (mg/reflect :dir :e) 5 1)
          reflected-ring (mg/reflect :dir :n :out [{} ring])
          inject #(-> ring
                      (assoc-in (child-path [1 1 0]) %)
                      (assoc-in (child-path [1 1 1 1 0]) %))
          ring-start (mg/reflect :dir :s :out [{} (inject reflected-ring)])]
      (mg/reflect
       :dir :s :out [(inject ring-start)
                     (inject reflected-ring)])))
  
  ;; apply to sphere lattice segment to form hemisphere
  (mg/save-mesh (mg/seed (mg/sphere-lattice-seg 6 0.25 0.0955 0.2)) t)
  
  ;; apply to circle lattice segment to form flat structure
  ;;(mg/save-mesh (mg/seed (mg/circle-lattice-seg 6 0.25 0.2)) t)
#+END_SRC

The example also includes a variation of the same tree applied to a
circle lattice segment forming a flat structure instead of a
hemisphere. Just uncomment the last line to see its result.

[[../assets/img/morphogen-ex03-flat.jpg]]

** TODO different node types

Sandbox/kitchen sink...

#+BEGIN_SRC clojure
  (defn rot-around-p [p q t] (g/+ q (g/rotate-y (g/- p q) t)))

  (def seed (BoxNode. (mapv g/vec3 [[0.25 0 0] [0 0 1] [1 0 1] [0.75 0 0] [0.35 0.25 0] [0.1 0.25 1] [0.9 0.25 1] [0.65 0.25 0]]) nil 0))

  ;; hex flat
  (def seed (BoxNode. (mapv vec3 [[-0.5 -0.866025 0] [-0.5 -0.866025 1] [0.5 -0.866025 1] [0.5 -0.866025 0] [-0.375 -0.649519 0] [-0.375 -0.649519 1] [0.375 -0.649519 1] [0.375 -0.649519 0]]) nil 0))

  ;; hex sphere
  (def seed (BoxNode. (mapv vec3 [[-0.5 -0.866025 0] [-0.38453 -0.666025 0.25] [0.38453 -0.666025 0.25] [0.5 -0.866025 0]
			       [-0.38453 -0.666025 0.0] [-0.26906 -0.466025 0.25] [0.26906 -0.466025 0.25] [0.38453 -0.666025 0.0]]) nil 0))

  ;; octagon
  (def seed (BoxNode. (mapv vec3 [[-0.38268 -0.923879 0.0] [-0.34126 -0.823879 0.25] [0.34126 -0.823879 0.25] [0.38268 -0.923879 0.0]
			       [-0.29984 -0.723879 0.0] [-0.25842 -0.623879 0.25] [0.25842 -0.623879 0.25] [0.29984 -0.723879 0.0]]) nil 0))
#+END_SRC
